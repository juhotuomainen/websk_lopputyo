// Tama on paatiedosto  eli se, josta sovellus kaynnistetaan */
// express kayttoon
const express = require('express');
// body-parser kayttoon
const bodyParser = require('body-parser');
// Express-session otetaan käyttöön. Tieto session-muuttujassa.
const session = require('express-session');
// Otetaan evästeiden lukija käyttöön requirella. Se muuttaa evästeen sisällön solluksen ymmärtämään muotoon.
const cookieParser = require('cookie-parser');
// path käyttöön requirella
const path =require('path');
// logger käyttöön reruirella.
const logger = require('morgan');
// index-reitti käyttöön requirella
const index = require('./app/routes/index');
// Googlen Kontrolleritiedosto käyttöön requirella. Sisältää Googlen kirjautumiseen ja tunnistautumiseen (autentikaatio)  tarvittavat toiminnot.
//const googleController = require('./app/controllers/googleController');
// käyttäjäreitti käyttöön requirella
const users = require('./app/routes/users');
// Opiskelijareitti käyttöön
const students = require('./app/routes/studentroute');
// Otetaan passport käyttöön requirella
const passport = require('passport');
// otetaan passportfunction käyttöön requirella. Tieto passportFUnction-muuttujassa.
const passportFunction = require('./passportfunction');
// suoritetaan passport-tiedosto aina app.js:n käynnistyessä kutsumalla passportFunction-muuttujaa ja antamalla sen parametriksi passport-kirjasto sulkujen sisällä.
passportFunction(passport);


// Tehdaan express-sovellus kutsumalla express()-metodia
const app = express();
// dotenv käyttöön
const dotenv = require('dotenv');
/* Määritellään dotenv-moduuli käyttöön kutsumalla todenv.muuttujan  kautta config-metodia, jolle välitetään suluissa olio. Sen avain on path ja arvo merkkijonotyyppinen tiedostopolku  (määritellään heittomerkkien sisään). Tiedostopolun osoituksessa on käytetty suhteellista eli relatiivista osoitustapaa, jossa tiedostopolku on mainittu siitä hakemistosta käsin, jossa ollaan (siis työhakemisto). */
dotenv.config({path:'./config/kayttajatiedot.env'});
/* Dotenv-muuttujan käyttö nodejs:n omaan process-luokkaan viitaamalla (viitataan siis process-luokan env-aliluokan secret-kenttään eli secret-avaimeen, joka löytyy app-kansion config-alikansiosta löytyvästä kayttajatiedot.env-tiedostosta. */
process.env.secret;
// Otetaan authController.js-tiedosto käyttöön. Siinä sijaitsee sovelluksen authentikaatio (käyttäjän todennus, authentication) ja authorisaatio (käyttäjän oikeuksien tarkistus, authorisaatio)
const authController = require('./app/controllers/authController.js');
//
// Patkitaan pyynnot, jotka ovat tyyppia sovellus/x-www-form-urlencoded.
app.use(bodyParser.urlencoded({ 
extended: true}));
// asetetaan backendin ejs-sivut sisältävä views-kansio siten, että sitä voidaan käyttää.. Siihen käytetään app-luokan set-metodia.
app.set('views', path.join(__dirname, 'views'));
// asetetaan näkymien moottori ejs:ksi. Kummatkin ovat heittomerkkejä.
app.set('view engine', 'ejs');


// patkitaan pyynnot, joiden tyyppi on sovellus (application)/json. Tassa hyodynnetaan bodyParser-muuttujan kautta kutsuttavaa json-metodia.
app.use(bodyParser.json());
// Otetaan tiedostoja kayttoon
// ensiksi konfiguraatio, joka luotiin database.config.js-tiedostoon. Tieto siitä tallennetaan dbConfig-muuttujaan.
// käytetään loggeria kehitysversiossaantamalla app-luokan set-metodille parametrina logger, jonka parametrina on puolestaan merkkijono dev.
app.use(logger('dev'));
// käytetään evästeiden parsijaa
app.use(cookieParser());
/* käytetään expressin staattista polun liittoa. Ensin on app-luokan use-metodin kutsu, jonka parametrina on puolestaan expressin static-metodin kutsu, jonka parametrina on path-luokan join-metodi. Sen parametrina on __dirname (osoittaa tiedot hakemistopolkuun) ja merkkijono public, mikä liittää public-kansion siten, että se tunnistetaan. */
//app.use(express.static(path.join(__dirname, 'public')));
/* otetaan sovelluksen session käyttöön app.use-lausekkeella. App-luokan use-metodin parametriksi tulee session-in kutsu, jonka parametrina on olio. Se sisältää tiedon joka sessioon erikseen luotavasta salausavaimesta (avain secret jaa arvo process-luokan kautta kutsutun env-muuttujan sisältämä SESSION_SECRET-ominaisuus (process.env.SESSION_SECRET) sekä kaksi totuusarvoa: tiedot uudelleentallennetaan (avain resave ja arvo true eli tosi) ja muutokset tallennetaan luomattomina (avain saveUninitialized ja arvo true eli tosi). */
app.use(session({secret: 'LÖLKIJFIEJGLGKGJIFIEOFJFKDKFIz<E', resave: true, saveUninitialized: true}));
/*passportin virallinen käyttöönotto. Kutsutaan passport-muuttujan kautta passportin initialize-metodia. */
app.use(passport.initialize());
// passportin sisäänkirjautumissession luonti: kutsutaan passport-muuttujan kautta passportin session-metodia antamalla se parametriksi app-luokan use-metodille.
app.use(passport.session());

// pääreitit (index ja users) käyttöön
// Otetaan index-reitti käyttöön kutsumalla app-luokan use-metodia, parametrina polku (merkkijono kautta) ja metodin nimi (index).
app.use('/', index);
// Otetaan users-reitti käyttöön kutsumalla app-luokan use-metodia, parametrina polku (merkkijono kautta) ja metodin nimi (users).
app.use('/users', users);
// Opiskelijareitti käyttöön app-muuttujan kautta kutsuttavalla use-metodilla. Ensin parametrina heittomerkeissä merkkijono (eli osoite, josta opiskelijoita etsitään) ja sitten moduulin nimi, johon viitataan.
app.use('/students', students);
const dbConfig =require('./config/database.config.js');
// mongoose-kirjasto kayttoon. Tieto mongoose-muuttujassa.
const mongoose = require('mongoose');
// tehdaan promise mongooselle ja dsijoitetaan se globaaliin Promise-metodiin.
mongoose.Promise = global.Promise;
// yhdistetaan tietokantaan mongoose.connect-metodilla. jolle annetaan parametriksi dbConfig-muuttujan kautta ktusuttava url-metodi (eli viitataan siis configuraation url-avaimeen)
mongoose.connect(dbConfig.url, { 
// kaytetaan uutta UrlParseria.
useNewUrlParser: true,
// Kaytetaan yhdistettya topologiaa (Unified topology). En tieda, mita se tarkoittaa.
useUnifiedTopology: true
})
// ketjutetaan asken tehdyt asiat (eli yhdistaminen) ketjutetaan then-metodille, jossa on onnistuneen yhteydenottoilmoituksen tulostava anonyymi nuolifunktio. Funktiolla ei ole siis nimeä eikä parametreja.

.then (() => {
// Tulostetaan viesti konsoliin.
console.log('Yhdistettiin onnistuneesti tietokantaan!');
})
// Ketjutus eteenpain .catch-lohkolle, joka ottaa vastaan virheen. Siina tulostetaan virheviesti virheineen konsoliin. Parametrina err-muuttuja
.catch ((err) => 
{
console.log('Ei voitu yhdistää tietokantaan. Syynä ' + err);
// Lopetetaan prosessi process.exit-metodilla
process.exit();
});
/* Maaritellaan yksinkertainen reitti. Ensin kutsutaan router.get-metodia, jonka ensimmaiseksi parametriksi heittomerkeissa kirjoitetaan kauttaviiva ja sitten callback-funktio, joka otaa parametriksi pyynnon ja vastauksen (parametrimuuuttujat req ja res) ja valittaa res-luokan json-metodille json-datamuodossa viestin, joka tulostetaan ilmeisesti sovelluksen kaynnistyessa.*/
//app.get('/', (req, res) => {
//res.json({"message": "Tervetuloa RestAPI-harjoitussovellukseen!"});
//});
// liitetaan tiedosto studentroute osaksi päätiedostoa
const studentroute = require('./app/routes/studentroute.js')(app);
/* Tommmin koodista poiketen omassa koodissani ei ole next-parametria kahden app.use-lauseen sisältämän anonyymin  nuolifunktion ensimmäisenä olevan (virheen kaappaajan ja toisena olevan virheenkäsittelijämetodin) parametrilistassa, sillä en halua viedä näitä asioita moduuliin.*/
app.use((req, res) => {
const err = new Error('Sivua ei löytynyt.');
// Asetetaan virheelle http-pyynnön mukana ominaisuus 404, mikä tarkoittaa sivun lataamisvirhettä.
res.status = 404;
})
// ketjutetaan virheenkäsittely eteenpäin virheenkäsittelyfunktiolle, joka tulostaa sivun näkyviin jos tarpeen.
app.use((err, req, res) => {
// asetetaan lokaalit, jotka tuottavat virheitä vain kehityksessä eli käytettäessä ohjelmistoa kehitystilassa.
// asetetaan err-muuttujan viestin arvoksi res-muuttujan locals-luokan message.ominaisuus (property)
res.locals.message = err.message;
/* Toteutetaan vertailu. Jos pyynnön get-reitissä tehty vertailu (eli merkkijonomuuttujien env ja development sisältö täsmää) on totta (thernary eli ?-operaattorin jälkeinen osa), palautetaan err-muuttuja. Muutoin (kaksoispisteen eli :-merkin jälkeinen osa) palautetaan tyhjä olio ({}). Vertailu on tehty suoraa verrannollisuutta (Strict Equality) hyödyntäen, mikä on suositeltavin vertailutapa JavaScriptiä käytettäessä. */
res.locals.error = req.app.get('env' === 'development' ? err : {});
// renderöidään (ikään kuin valmistellaan) sivu käyttöön
/* lähetetään res-luokan status-metodia hyödyntäen virhe. Annetaan sen sisällä suluissa parametriksi err-muuttujan status-ominaisuuden tieto tai (looginen tai ||) numero 500, joka on yleinen palvelinvirhe. */
res.status(err.status || 500);
// Renderöidään sivu nimellä virhe antamalla sana virhe render-luokan error-oliolle parametrina
res.render('error');
});
// Kuunnellaan pyyntoja. Tassa hyodynnetaan listen-metodia, jolle valitetaan parametrina portti seka kalback-nuolifunktio, joka tulostaa portin konsoliin.

app.listen(3000,  () => {
// Tulostetaan viesti konsoliin kayttaen console.log:ia.
console.log('Palvelin käynnissä portissa 3000.');
});